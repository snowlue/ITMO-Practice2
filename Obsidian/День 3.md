Как выяснилось, алгоритм хорошо работал на симулированных данных, но всё ещё некорректно отрабатывал на данных с лидара. Это было связано с размерностями и неверным пониманием, что есть `src`, а что `dst`.
- `dst` — облако точек с предыдущего сканирования лидаром
- `src` — новое облако точек, которое необходимо подвинуть к `dst`
В случае с алгоритмом, описанным в [[ICP]], `src` является $S_n$, а `dst` является $S_{n-1}$.

Расположили хранилище Obsidian в репозитории.

Таким образом, в течение дня отлаживали алгоритм, чтобы он верно работал:
- Заменили перебор всех ближайших точек на оптимальный `KDTree`
- Проверили, что `SVD` в `numpy` работает так, как мы ожидаем

Начали записи сканов с лидара в `pkl`-файлы, чтобы воспроизводить сканы в `matplotlib` и отлаживать алгоритм там.